<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Merry Christmas from Zhou</title>
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Great+Vibes&display=swap"
        rel="stylesheet">

    <!-- MediaPipe Import -->
    <script type="importmap">
    { "imports": { "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8" } }
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            overscroll-behavior: none;
            touch-action: none;
            background: radial-gradient(circle at center, #1a1a3a 0%, #03030c 100%);
            font-family: 'Great Vibes', cursive;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            user-select: none;
            cursor: pointer;
        }

        #canvasContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #4ECDC4;
            font-size: 20px;
            z-index: 10;
            font-family: 'Arial', sans-serif;
            transition: opacity 0.5s;
        }

        #textContainer {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 13vh;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
            mix-blend-mode: screen;
        }

        #mainText {
            font-family: 'Great Vibes', cursive;
            font-size: min(10vw, 8vh);
            font-weight: 400;
            letter-spacing: 3px;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
            opacity: 0;
            transform: translateY(30px);
            animation: textFloatIn 2s ease-out forwards 1s, textGlow 3s ease-in-out infinite 3s;
        }

        @keyframes textFloatIn {
            0% {
                opacity: 0;
                transform: translateY(30px)
            }

            100% {
                opacity: 1;
                transform: translateY(0)
            }
        }

        @keyframes textGlow {

            0%,
            100% {
                text-shadow: 0 0 10px gold
            }

            50% {
                text-shadow: 0 0 25px gold
            }
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 200;
            display: flex;
            gap: 10px;
        }

        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.4);
            color: #FFD700;
            padding: 8px 15px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            font-family: sans-serif;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: rgba(255, 215, 0, 0.2);
            transform: scale(1.05);
        }

        #webcam {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 60px;
            object-fit: cover;
            transform: scaleX(-1);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            z-index: 150;
            display: none;
            opacity: 0.8;
            pointer-events: none;
        }

        #hand-cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 2px solid cyan;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 300;
            box-shadow: 0 0 10px cyan;
            transition: background 0.2s;
        }

        #hand-cursor.pinching {
            background: rgba(0, 255, 255, 0.6);
            transform: translate(-50%, -50%) scale(0.8);
        }

        #photoModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 500;
            align-items: center;
            justify-content: center;
        }

        #photoContent {
            max-width: 90%;
            max-height: 85%;
            border: 4px solid gold;
            border-radius: 10px;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.2);
        }

        #debug {
            position: fixed;
            top: 0;
            right: 0;
            color: lime;
            font-family: monospace;
            z-index: 9999;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            font-size: 10px;
            pointer-events: none;
            display: none;
        }
    </style>
</head>

<body>
    <div id="debug"></div>
    <div class="controls">
        <button onclick="window.APP.initCamera()">üì∑ ÂºÄÂêØÁõ∏Êú∫(ÊâãÂäø)</button>
        <button onclick="document.getElementById('fileInput').click()">üñºÔ∏è ÊîæÂÖ•ÁÖßÁâá</button>
    </div>
    <input type="file" id="fileInput" multiple accept="image/*" style="display:none"
        onchange="window.APP.handleUpload(this)">

    <div id="canvasContainer">
        <canvas id="christmasCanvas"></canvas>
        <div id="loading"></div>
        <div id="textContainer">
            <div id="mainText">Merry ChristmasüéÑ</div>
        </div>
    </div>

    <video id="webcam" autoplay playsinline muted></video>
    <div id="hand-cursor"></div>
    <div id="photoModal" onclick="this.style.display='none'"><img id="photoContent"></div>

    <script type="module">
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        window.HAND_STATE = { gesture: 'IDLE', x: 0, y: 0, pinching: false, active: false, historyX: [] };
        let handLandmarker;
        let running = false;
        let lastSwipeTime = 0;

        window.APP = window.APP || {};
        window.APP.initCamera = async () => {
            const loading = document.getElementById('loading');
            loading.style.display = 'block'; loading.innerText = "Ê≠£Âú®ÂêØÂä®È≠îÊ≥ïÁúº...";
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                    runningMode: "VIDEO", numHands: 1
                });

                const video = document.getElementById('webcam');
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: 'user' } });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    running = true; predictWebcam();
                    video.style.display = 'block'; document.getElementById('hand-cursor').style.display = 'block';
                    loading.style.display = 'none';
                });
            } catch (e) { console.error(e); alert("Camera Error: " + e); loading.style.display = 'none'; }
        };

        window.APP.handleUpload = (input) => {
            if (window.christmasAnimation) window.christmasAnimation.addPhotos(input.files);
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (!running) return;
            const video = document.getElementById('webcam');
            const h = window.HAND_STATE;
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, performance.now());
                if (results.landmarks && results.landmarks.length > 0) {
                    const lm = results.landmarks[0];
                    h.active = true;
                    const wrist = lm[0];
                    const tips = [8, 12, 16, 20]; const pips = [6, 10, 14, 18];
                    let ext = 0;
                    tips.forEach((t, i) => { if (Math.hypot(lm[t].x - wrist.x, lm[t].y - wrist.y) > Math.hypot(lm[pips[i]].x - wrist.x, lm[pips[i]].y - wrist.y)) ext++; });

                    if (ext === 4) h.gesture = 'OPEN_PALM';
                    else if (ext === 0) h.gesture = 'FIST';
                    else if (ext === 1 && tips[0] === 8) h.gesture = 'POINT'; // Simplified check for pointing
                    else h.gesture = 'POINT';

                    h.x = (1 - lm[8].x) * 100; h.y = lm[8].y * 100;

                    // Swipe Detection logic
                    if (window.christmasAnimation && window.christmasAnimation.explosionFactor > 0.5) {
                        const now = Date.now();
                        if (now - lastSwipeTime > 500) { // Debounce
                            h.historyX.push({ x: h.x, t: now });
                            if (h.historyX.length > 10) h.historyX.shift();

                            // Check for swipe
                            if (h.historyX.length >= 5) {
                                const start = h.historyX[0];
                                const end = h.historyX[h.historyX.length - 1];
                                const diffX = end.x - start.x;
                                const dur = end.t - start.t;

                                if (dur < 300 && Math.abs(diffX) > 15) { // Fast movement
                                    if (diffX > 0) window.christmasAnimation.switchPhoto(-1); // Right swipe -> prev
                                    else window.christmasAnimation.switchPhoto(1); // Left swipe -> next
                                    lastSwipeTime = now;
                                    h.historyX = [];

                                    // Visual Feedback
                                    const cur = document.getElementById('hand-cursor');
                                    cur.style.borderColor = "#FF0000";
                                    setTimeout(() => cur.style.borderColor = "cyan", 200);
                                }
                            }
                        }
                    }

                    const cur = document.getElementById('hand-cursor');
                    cur.style.left = h.x + '%'; cur.style.top = h.y + '%';

                    const d = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                    const wasPinching = h.pinching;
                    h.pinching = d < 0.06;

                    if (h.pinching) cur.classList.add('pinching'); else cur.classList.remove('pinching');
                    if (!wasPinching && h.pinching && window.christmasAnimation) window.christmasAnimation.handleHandClick(h.x, h.y);
                    cur.style.borderColor = (h.gesture === 'OPEN_PALM' ? 'magenta' : (h.gesture === 'FIST' ? 'yellow' : 'cyan'));
                } else { h.active = false; h.gesture = 'IDLE'; h.historyX = []; }
            }
            requestAnimationFrame(predictWebcam);
        }
    </script>

    <script>
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        class ChristmasAnimation {
            constructor() {
                try {
                    this.canvas = document.getElementById('christmasCanvas');
                    this.ctx = this.canvas.getContext('2d');
                    this.loading = document.getElementById('loading');

                    this.photos = [];
                    this.currentPhotoIndex = 0;
                    this.explosionFactor = 0;
                    this.modalTimer = null;

                    this.isMobileDevice = isMobile;
                    this.performanceMultiplier = isMobile ? 0.7 : 1;

                    this.autoRotation = 0;
                    this.rotationSpeed = 0.005;
                    this.growthProgress = 0; this.maxGrowth = 1;

                    this.setupCanvas();
                    this.initColors();
                    this.createScene();
                    this.startAnimation();

                    window.addEventListener('resize', () => this.handleResize());
                    this.canvas.addEventListener('click', e => this.handleClick(e.clientX, e.clientY));
                } catch (e) {
                    console.error("Constructor", e);
                    document.getElementById('debug').style.display = 'block';
                    document.getElementById('debug').innerText = e.message;
                }
            }

            setupCanvas() {
                const getScreenDimensions = () => {
                    return {
                        width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
                        height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
                    };
                };

                const { width, height } = getScreenDimensions();

                // 1. Setup Canvas & DPR
                this.dpr = Math.min(window.devicePixelRatio || 1, this.isMobileDevice ? 2.5 : 3);
                this.screenWidth = width;
                this.screenHeight = height;
                this.canvas.width = Math.round(this.screenWidth * this.dpr);
                this.canvas.height = Math.round(this.screenHeight * this.dpr);
                this.canvas.style.width = `${this.screenWidth}px`;
                this.canvas.style.height = `${this.screenHeight}px`;

                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(this.dpr, this.dpr);

                this.centerX = this.screenWidth / 2;
                this.centerY = this.screenHeight / 2;

                // Reference Script Scaling Logic
                const baseSize = Math.min(this.screenWidth, this.screenHeight);
                const referenceSize = Math.min(850, Math.max(500, baseSize));
                this.treeScale = baseSize / referenceSize;

                // Mobile adjustments
                if (this.screenHeight > this.screenWidth * 1.5) {
                    this.treeScale *= 0.9;
                }
                if (this.isLandscapeMode && this.isMobileDevice) {
                    this.treeScale *= 0.85;
                }

                // Reference Script Position Logic
                this.trunkBaseY = this.screenHeight * 0.7;
                this.crownBaseY = this.screenHeight * 0.82;
            }

            handleResize() { this.setupCanvas(); this.createScene(); }

            initColors() {
                this.TREE_COLORS = ["#2E8B57", "#3CB371", "#20B2AA", "#66CDAA", "#00FA9A"];
                this.LIGHT_COLORS = ["#FF6B9D", "#FFD166", "#7CE6E6", "#FF8AF0", "#FFA552", "#93FF9B"];
                this.TRUNK_COLORS = ["#5C3317", "#6F4E37", "#8B4513"];
                this.GIFT_COLORS = [
                    { box: "#FF6B6B", ribbon: "#FFD166" }, { box: "#4ECDC4", ribbon: "#FFE66D" },
                    { box: "#95E1D3", ribbon: "#F38181" }, { box: "#FF8AF0", ribbon: "#7CE6E6" },
                    { box: "#FFD166", ribbon: "#FF6B9D" }, { box: "#A8E6CF", ribbon: "#FFAAA5" },
                    { box: "#FFD3B6", ribbon: "#A8E6CF" }, { box: "#D4A5A5", ribbon: "#FFE8E8" },
                ];
                this.SPIRAL_LIGHT_COLORS = ["#FF6B9D", "#FFD166", "#7CE6E6", "#FF8AF0", "#4ECDC4", "#95E1D3", "#A8E6CF", "#FFD3B6"];
            }

            noise(seed, t) {
                return (Math.sin(t * 0.7 + seed * 12.345) + Math.sin(t * 1.3 + seed * 4.56) * 0.5) * 0.5;
            }

            createScene() {
                this.particles = []; this.lights = []; this.snowflakes = []; this.stars = []; this.topStar = null;
                this.gifts = []; this.upperGifts = []; this.topGifts = []; this.spiralLights = [];

                const trunkMultiplier = this.performanceMultiplier;
                const particleMultiplier = this.performanceMultiplier;
                // Keep gift multiplier standard? Or use logic? Reference script used performanceMultiplier. 
                // We will stick to our existing Gift logic for now as requested ("gift part unchanged"), but regenerate them with new scale logic.
                // Actually user said "gift part unchanged", likely meaning the *rendering/interaction*, but positions must match new tree.

                this.createChristmasTreeTrunk(trunkMultiplier);
                this.createChristmasTreeCrown(particleMultiplier);
                this.createSnowflakes();
                this.createTopStar();

                // Re-creating gifts to match new scale/position
                this.createTopGifts();
                this.createUpperGifts();
                this.createGifts();
                this.createSpiralLights(particleMultiplier);

                if (this.loading) this.loading.style.display = 'none';
            }

            createChristmasTreeTrunk(multiplier = 1) {
                const trunkHeight = 140 * this.treeScale;
                const trunkRadius = 50 * this.treeScale;
                const trunkCount = Math.floor(1000 * multiplier);
                for (let i = 0; i < trunkCount; i++) {
                    const p = i / trunkCount;
                    const y = this.trunkBaseY + p * trunkHeight;
                    const angle = i * 2.39996;
                    const currentRadius = trunkRadius * (1 - 0.2 * p);
                    const r = currentRadius * Math.sqrt(Math.random()) * (0.5 + Math.random() * 0.5);
                    const x = Math.cos(angle) * r; const z = Math.sin(angle) * r;

                    let color;
                    if (z > 0) color = this.TRUNK_COLORS[2];
                    else if (y > this.trunkBaseY + trunkHeight * 0.6) color = this.TRUNK_COLORS[0];
                    else color = this.TRUNK_COLORS[1];

                    this.particles.push({
                        x: x, y: y, z: z, baseX: x, baseY: y, color: color,
                        size: Math.random() * 3.5 + 3, swaySpeed: 0, swayOffset: 0, isTrunk: true, growth: 1
                    });
                }
            }

            createChristmasTreeCrown(multiplier = 1) {
                const particleCount = Math.floor(3500 * multiplier);
                const treeHeight = 620 * this.treeScale;
                const maxRadius = 280 * this.treeScale;
                const spiralFactor = 10;
                for (let i = 0; i < particleCount; i++) {
                    const p = i / particleCount;
                    const spiralAngle = i * 2.39996 + p * spiralFactor;
                    const currentHeight = treeHeight * p;
                    const currentRadius = maxRadius * (1 - p);
                    const r = currentRadius * Math.sqrt(Math.random()) * (0.8 + Math.random() * 0.4);
                    const x = Math.cos(spiralAngle) * r;
                    const y = this.crownBaseY - currentHeight;
                    const z = Math.sin(spiralAngle) * r;

                    if (Math.random() < 0.18) {
                        const color = this.LIGHT_COLORS[Math.floor(Math.random() * this.LIGHT_COLORS.length)];
                        const glow = 8 + Math.random() * 24;
                        const sparkleChance = Math.random() < 0.15 ? 0.01 + Math.random() * 0.03 : 0;

                        this.lights.push({
                            x: x, y: y, z: z, baseX: x, baseY: y,
                            color: color, size: Math.random() * 3.5 + 2.5,
                            blinkSpeed: 1.0 + Math.random() * 3.5, blinkOffset: Math.random() * Math.PI * 2,
                            baseAlpha: 0.5 + Math.random() * 0.6, glow: glow, growth: 1, spiralAngle: spiralAngle,
                            flickerSeed: Math.random() * 1000, sparkleChance: sparkleChance
                        });
                    } else {
                        this.particles.push({
                            x: x, y: y, z: z, baseX: x, baseY: y,
                            color: this.TREE_COLORS[Math.floor(Math.random() * this.TREE_COLORS.length)],
                            size: Math.random() * 1.8 + 0.6, swaySpeed: Math.random() * 2 + 1,
                            swayOffset: Math.random() * Math.PI * 2, isTrunk: false, growth: 1, spiralAngle: spiralAngle
                        });
                    }
                }
            }

            _createGifts(arr, count, hStart, hRatio, layer, spiralFactor = 8) {
                const treeHeight = 620 * this.treeScale;
                const maxRadius = 280 * this.treeScale;
                for (let i = 0; i < count; i++) {
                    const hr = hStart + Math.random() * hRatio;
                    const currentHeight = treeHeight * hr;
                    const y = this.crownBaseY - currentHeight;
                    const radiusRatio = 0.5 + Math.random() * 0.4;
                    const currentRadius = maxRadius * (1 - hr) * radiusRatio;
                    const spiralAngle = i * (Math.PI * 2 / count) + hr * spiralFactor;
                    const x = Math.cos(spiralAngle) * currentRadius; const z = Math.sin(spiralAngle) * currentRadius;
                    const colIdx = Math.floor(Math.random() * this.GIFT_COLORS.length);
                    arr.push({
                        x: x, y: y, z: z, baseX: x, baseY: y,
                        color: this.GIFT_COLORS[colIdx].box, ribbonColor: this.GIFT_COLORS[colIdx].ribbon,
                        size: (0.75 + Math.random() * 0.75) * this.treeScale * 30,
                        rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.01,
                        swaySpeed: 0.5 + Math.random(), swayOffset: Math.random() * Math.PI * 2,
                        growth: 1, spiralAngle: spiralAngle, layer: layer, sparkleTimer: 0, glow: 0, sparkleIntensity: 0.5
                    });
                }
            }
            createTopGifts() { this._createGifts(this.topGifts, 5, 0.05, 0.08, 'top', 12); }
            createUpperGifts() { this._createGifts(this.upperGifts, 8, 0.15, 0.2, 'upper', 8); }
            createGifts() { this._createGifts(this.gifts, 8, 0.3, 0.2, 'middle', 8); }

            createSpiralLights() {
                const treeHeight = 620 * this.treeScale; const maxRadius = 280 * this.treeScale;
                const spiralCount = this.isMobileDevice ? 60 : 100; const spiralTurns = 5;
                for (let i = 0; i < spiralCount; i++) {
                    const t = i / spiralCount;
                    const y = this.crownBaseY - treeHeight * t;
                    const angle = t * Math.PI * 2 * spiralTurns + t * 10;
                    const r = maxRadius * (1 - t * 0.8) * (0.7 + Math.random() * 0.3);
                    this.spiralLights.push({
                        x: 0, y: y, z: 0, baseX: Math.cos(angle) * r, baseY: y, z: Math.sin(angle) * r,
                        color: this.SPIRAL_LIGHT_COLORS[i % this.SPIRAL_LIGHT_COLORS.length],
                        size: 1.8 + Math.random() * 1.8, pulseSpeed: 2 + Math.random() * 2, phase: Math.random() * Math.PI * 2,
                        baseAlpha: 0.6 + Math.random() * 0.4, glow: 10 + Math.random() * 20, trailLength: 5, trailOffset: 0, growth: 1, spiralAngle: angle
                    });
                }
            }

            createSnowflakes() {
                const snowflakeCount = this.isMobileDevice ? 200 : 500;
                for (let i = 0; i < snowflakeCount; i++) {
                    this.snowflakes.push({
                        x: Math.random() * this.screenWidth,
                        y: Math.random() * this.screenHeight,
                        z: Math.random() * 2 + 0.5,
                        size: Math.random() * 4 + 3, baseSize: Math.random() * 4 + 3,
                        speedY: Math.random() * 1 + 0.5, swayAmp: Math.random() * 2,
                        swayFreq: Math.random() * 0.02, opacity: Math.random() * 0.6 + 0.3,
                        rotation: Math.random() * Math.PI * 2, rotationSpeed: (Math.random() - 0.5) * 0.05,
                        type: Math.floor(Math.random() * 3), growth: 0, targetSize: Math.random() * 1.8 + 1, growthSpeed: Math.random() * 0.003 + 0.001
                    });
                }
            }

            createTopStar() {
                const treeHeight = 620 * this.treeScale;
                this.topStar = {
                    x: this.centerX,
                    y: this.crownBaseY - treeHeight - 30 * this.treeScale,
                    size: 30 * this.treeScale,
                    color: '#FFD700',
                    rotation: 0,
                    rotationSpeed: 0.01,
                    spikes: 5,
                    innerRadius: 0.4,
                    glowSize: 48 * this.treeScale
                };
            }

            addPhotos(files) {
                if (!files.length) return;
                Array.from(files).forEach(f => {
                    const r = new FileReader();
                    r.onload = e => { const i = new Image(); i.src = e.target.result; this.photos.push(i); this.assignPhotos(); };
                    r.readAsDataURL(f);
                });
            }
            assignPhotos() {
                const all = [...this.gifts, ...this.upperGifts, ...this.topGifts];
                all.forEach((g, i) => { if (this.photos.length) g.photo = this.photos[i % this.photos.length]; });
            }

            handleClick(cx, cy) {
                const allGifts = [...this.gifts, ...this.upperGifts, ...this.topGifts];
                for (let g of allGifts) {
                    if (g.calcX && g.calcY) {
                        const d = Math.hypot(g.calcX - cx, g.calcY - cy);
                        // Increase hit area slightly for better usability
                        if (d < g.size * g.calcScale * 1.5) {
                            if (g.photo) {
                                this.currentPhotoIndex = this.photos.indexOf(g.photo);
                                if (this.currentPhotoIndex === -1) this.currentPhotoIndex = 0;
                                this.updateModalPhoto();
                                document.getElementById('photoModal').style.display = 'flex';
                                this.resetModalTimer();
                            } else if (this.photos.length > 0) {
                                this.currentPhotoIndex = 0;
                                this.updateModalPhoto();
                                document.getElementById('photoModal').style.display = 'flex';
                                this.resetModalTimer();
                            }
                            break;
                        }
                    }
                }
            }

            switchPhoto(dir) {
                const modal = document.getElementById('photoModal');
                if (!modal || modal.style.display === 'none') {
                    // If hidden, show it first (auto-open on swipe in scattered mode)
                    modal.style.display = 'flex';
                    this.resetModalTimer();
                    return;
                }
                if (this.photos.length === 0) return;

                this.currentPhotoIndex += dir;
                if (this.currentPhotoIndex < 0) this.currentPhotoIndex = this.photos.length - 1;
                if (this.currentPhotoIndex >= this.photos.length) this.currentPhotoIndex = 0;

                this.updateModalPhoto();
                this.resetModalTimer();
            }

            resetModalTimer() {
                if (this.modalTimer) clearTimeout(this.modalTimer);
                this.modalTimer = setTimeout(() => {
                    document.getElementById('photoModal').style.display = 'none';
                }, 3000);
            }

            updateModalPhoto() {
                if (this.photos.length > 0 && this.photos[this.currentPhotoIndex]) {
                    document.getElementById('photoContent').src = this.photos[this.currentPhotoIndex].src;
                }
            }

            handleHandClick(px, py) { this.handleClick(px / 100 * this.screenWidth, py / 100 * this.screenHeight); }

            update() {
                const h = window.HAND_STATE;

                if (typeof this.targetExplosionFactor === 'undefined') {
                    this.targetExplosionFactor = 0;
                }

                if (h && h.active) {
                    if (h.gesture === 'OPEN_PALM') {
                        this.targetExplosionFactor = 1;
                    } else if (h.gesture === 'FIST') {
                        this.targetExplosionFactor = 0;
                    }
                }

                this.explosionFactor += (this.targetExplosionFactor - this.explosionFactor) * 0.12;

                const time = Date.now() / 1000;
                this.autoRotation += this.rotationSpeed;
                if (this.growthProgress < this.maxGrowth) this.growthProgress += 0.001;

                // Êõ¥Êñ∞Á≤íÂ≠ê‰ΩçÁΩÆ
                this.particles.forEach(p => {
                    const rot = this.autoRotation;
                    const cos = Math.cos(rot), sin = Math.sin(rot);
                    const gf = Math.min(1, p.growth + this.growthProgress);

                    let ex = 0, ey = 0;
                    if (this.explosionFactor > 0.01 && !p.isTrunk) {
                        const d = Math.hypot(p.baseX, p.baseY - this.crownBaseY, p.z) || 1;
                        const m = this.explosionFactor * (this.screenWidth * 2);
                        ex = (p.baseX / d) * m; ey = ((p.baseY - this.crownBaseY) / d) * m;
                    }

                    p.x = (p.baseX * cos - p.z * sin) * gf + this.centerX + ex;
                    if (!p.isTrunk) {
                        const sway = Math.sin(time * 0.5 + p.spiralAngle) * 2;
                        p.y = p.baseY + Math.sin(time * p.swaySpeed + p.swayOffset) * 2 * gf + sway + ey;
                    } else {
                        p.y = p.baseY * gf;
                    }
                });

                // Êõ¥Êñ∞Ëû∫ÊóãÁÅØ
                this.spiralLights.forEach(light => {
                    const rot = this.autoRotation;
                    const cos = Math.cos(rot), sin = Math.sin(rot);
                    const gf = Math.min(1, light.growth + this.growthProgress);
                    let ex = 0, ey = 0;
                    if (this.explosionFactor > 0.01) {
                        const d = Math.hypot(light.baseX, light.baseY - this.crownBaseY, light.z) || 1;
                        const m = this.explosionFactor * (this.screenWidth * 2);
                        ex = (light.baseX / d) * m; ey = ((light.baseY - this.crownBaseY) / d) * m;
                    }
                    light.x = (light.baseX * cos - light.z * sin) * gf + this.centerX + ex;
                    light.y = light.baseY * gf + ey;

                    const sinPart = (Math.sin(time * light.pulseSpeed + light.phase + light.spiralAngle) + 1) / 2;
                    light.alpha = Math.min(1, light.baseAlpha * (0.7 + 0.6 * sinPart));
                    light.trailOffset = (light.trailOffset + 1) % (light.trailLength + 1);
                });

                // Êõ¥Êñ∞Á§ºÁâ©
                const updateGift = (g) => {
                    const rot = this.autoRotation;
                    const cos = Math.cos(rot), sin = Math.sin(rot);
                    const gf = Math.min(1, g.growth + this.growthProgress);

                    let rx = g.baseX * cos - g.z * sin;
                    let rz = g.z * cos + g.baseX * sin;
                    let ry = g.baseY * gf + Math.sin(time * g.swaySpeed) * 2;
                    g.rotation += g.rotationSpeed + 0.002;

                    if (this.explosionFactor > 0.01) {
                        const ang = Math.atan2(g.z, g.baseX) + rot + Math.PI / 2;
                        const rad = Math.min(this.screenWidth, this.screenHeight) * 0.35 + (g.layer === 'top' ? 0 : (g.layer === 'upper' ? 50 : 100));
                        const tx = Math.cos(ang) * rad;
                        const ty = Math.sin(ang) * rad + this.centerY;
                        g.calcX = rx + (tx - rx) * this.explosionFactor + this.centerX;
                        g.calcY = ry + (ty - ry) * this.explosionFactor;
                        g.calcScale = 1 + (rz / 1000) * (1 - this.explosionFactor) + 0.5 * this.explosionFactor;
                    } else {
                        g.calcX = rx + this.centerX;
                        g.calcY = ry;
                        g.calcScale = 1 + rz / 1000;
                    }
                    g.lastDrawX = g.calcX;
                    g.lastDrawY = g.calcY;
                    if (g.sparkleTimer > 0) g.sparkleTimer--;
                };
                [...this.gifts, ...this.upperGifts, ...this.topGifts].forEach(updateGift);

                // Êõ¥Êñ∞ÁÅØÂÖâ
                this.lights.forEach(l => {
                    const rot = this.autoRotation;
                    const cos = Math.cos(rot), sin = Math.sin(rot);
                    const gf = Math.min(1, l.growth + this.growthProgress);
                    let ex = 0, ey = 0;
                    if (this.explosionFactor > 0.01) {
                        const d = Math.hypot(l.baseX, l.baseY - this.crownBaseY, l.z) || 1;
                        const m = this.explosionFactor * (this.screenWidth * 2);
                        ex = (l.baseX / d) * m; ey = ((l.baseY - this.crownBaseY) / d) * m;
                    }
                    l.x = (l.baseX * cos - l.z * sin) * gf + this.centerX + ex;
                    l.y = l.baseY * gf + ey;
                    const sinPart = (Math.sin(time * l.blinkSpeed + l.blinkOffset) + 1) / 2;
                    l.alpha = Math.min(1, l.baseAlpha * (0.6 + 0.8 * sinPart));
                });

                // Êõ¥Êñ∞Èõ™Ëä±
                this.snowflakes.forEach(s => {
                    if (s.growth < s.targetSize) {
                        s.growth += s.growthSpeed;
                    } else {
                        s.growth = 0;
                        s.targetSize = Math.random() * 1.8 + 1;
                    }

                    const currentSize = s.baseSize * (1 + s.growth);
                    s.y += s.speedY * s.z;
                    s.x += Math.sin(time + s.y * 0.01) * s.swayAmp;
                    s.rotation += s.rotationSpeed * (1 + s.growth * 0.5);
                    s.size = currentSize;

                    if (s.y > this.screenHeight) {
                        s.y = -10;
                        s.x = Math.random() * this.screenWidth;
                        s.size = s.baseSize = Math.random() * 4 + 3;
                        s.growth = 0;
                        s.targetSize = Math.random() * 1.8 + 1;
                    }
                    if (s.x > this.screenWidth) s.x = 0;
                    if (s.x < 0) s.x = this.screenWidth;
                });

                if (this.topStar) {
                    this.topStar.time = time;
                    this.topStar.rotation += this.topStar.rotationSpeed;
                }
            }

            startAnimation() {
                this.draw();
            }

            draw() {
                this.update();
                try {
                    // Ê∏ÖÁ©∫ÁîªÂ∏É
                    this.ctx.fillStyle = "#0a0a2a";
                    this.ctx.fillRect(0, 0, this.screenWidth, this.screenHeight);

                    this.ctx.globalCompositeOperation = 'lighter';
                    const gf = this.explosionFactor > 0.9 ? 0 : 1 - this.explosionFactor;

                    // ÁªòÂà∂Ê†ëÁ≤íÂ≠ê
                    if (gf > 0.01) {
                        this.particles.forEach(p => {
                            this.ctx.beginPath();
                            this.ctx.arc(p.x, p.y, p.size * this.treeScale * (p.isTrunk ? 1.5 : 1), 0, Math.PI * 2);
                            this.ctx.fillStyle = p.color;
                            this.ctx.globalAlpha = (p.isTrunk ? 0.9 : (this.isMobileDevice ? 0.3 : 0.6)) * gf;
                            this.ctx.fill();
                        });

                        // ÁªòÂà∂Ëû∫ÊóãÁÅØ
                        this.spiralLights.forEach(l => {
                            this.drawLightGlow(l.x, l.y, l.size * this.treeScale, l.color, l.alpha * gf, l.glow * this.treeScale);
                        });

                        // ÁªòÂà∂Ê†ëÁÅØ
                        this.lights.forEach(l => {
                            this.drawLightGlow(l.x, l.y, l.size * this.treeScale, l.color, l.alpha * gf, l.glow * this.treeScale);
                        });
                    }

                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.globalAlpha = 1;

                    // ÁªòÂà∂Á§ºÁâ©
                    const drawAGift = (g) => {
                        this.ctx.save();
                        if (isNaN(g.calcX) || isNaN(g.calcY)) {
                            this.ctx.restore();
                            return;
                        }
                        this.ctx.translate(g.calcX, g.calcY);

                        if (window.HAND_STATE && window.HAND_STATE.active) {
                            const hx = window.HAND_STATE.x / 100 * this.screenWidth;
                            const hy = window.HAND_STATE.y / 100 * this.screenHeight;
                            if (Math.hypot(g.calcX - hx, g.calcY - hy) < g.size * 2) {
                                this.ctx.shadowColor = "white";
                                this.ctx.shadowBlur = 20;
                            }
                        }

                        if (this.explosionFactor > 0.5 && g.photo) {
                            const sz = g.size * g.calcScale * 2.5;
                            const r = g.photo.width / g.photo.height;
                            this.ctx.beginPath();
                            this.ctx.fillStyle = "#fff";
                            this.ctx.fillRect(-sz * r / 2 - 2, -sz / 2 - 2, sz * r + 4, sz + 4);
                            this.ctx.drawImage(g.photo, -sz * r / 2, -sz / 2, sz * r, sz);
                        } else {
                            if (g.glow > 0) {
                                this.ctx.globalCompositeOperation = 'lighter';
                                const glowGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, g.size * g.calcScale * 2);
                                glowGradient.addColorStop(0, this.hexToRgba(g.color, g.glow * 0.3));
                                glowGradient.addColorStop(1, this.hexToRgba(g.color, 0));
                                this.ctx.fillStyle = glowGradient;
                                this.ctx.beginPath();
                                this.ctx.arc(0, 0, g.size * g.calcScale * 2, 0, Math.PI * 2);
                                this.ctx.fill();
                                this.ctx.globalCompositeOperation = 'source-over';
                            }
                            this.drawGift(0, 0, g.size * g.calcScale, g.rotation, g.color, g.ribbonColor, g.glow, (g.sparkleTimer > 0 ? g.sparkleIntensity : 0));
                        }
                        this.ctx.restore();
                    };
                    [...this.topGifts, ...this.upperGifts, ...this.gifts].forEach(drawAGift);

                    // ÁªòÂà∂Ê†ëÈ°∂ÊòüÊòü
                    if (this.topStar && gf > 0.01) {
                        const s = this.topStar;
                        this.ctx.globalCompositeOperation = 'lighter';
                        const g = this.ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.glowSize);
                        g.addColorStop(0, 'rgba(255,255,200,0.9)');
                        g.addColorStop(1, 'rgba(255,140,0,0)');
                        this.ctx.fillStyle = g;
                        this.ctx.beginPath();
                        this.ctx.arc(s.x, s.y, s.glowSize, 0, Math.PI * 2);
                        this.ctx.fill();

                        this.drawStar(s.x, s.y, s.spikes, s.size, s.size * s.innerRadius, s.color, s.rotation);
                        this.drawStar(s.x, s.y, s.spikes, s.size * 0.7, s.size * 0.7 * s.innerRadius, '#FFFACD', s.rotation + 0.1);
                        this.ctx.globalCompositeOperation = 'source-over';
                    }

                    this.ctx.globalCompositeOperation = 'source-over';
                    this.ctx.globalAlpha = 1;

                    // ÁªòÂà∂Èõ™Ëä±
                    this.snowflakes.forEach(s => {
                        if (this.isMobileDevice && s.z < 1.2) {
                            this.ctx.beginPath();
                            this.ctx.arc(s.x, s.y, s.size * 0.5, 0, Math.PI * 2);
                            this.ctx.fillStyle = `rgba(255, 255, 255, ${s.opacity * 0.7})`;
                            this.ctx.fill();
                        } else {
                            switch (s.type) {
                                case 0: this.drawHexagonSnowflake(s.x, s.y, s.size, s.rotation, s.opacity); break;
                                case 1: this.drawStarSnowflake(s.x, s.y, s.size, s.rotation, s.opacity); break;
                                case 2: this.drawFlowerSnowflake(s.x, s.y, s.size, s.rotation, s.opacity); break;
                            }
                        }
                    });

                } catch (e) {
                    console.error("Render Loop Error", e);
                }

                requestAnimationFrame(() => this.draw());
            }

            drawGift(x, y, size, rotation, boxColor, ribbonColor, glow = 0, sparkle = 0) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.fillStyle = boxColor;
                ctx.fillRect(-size / 2, -size / 2, size, size);
                ctx.fillStyle = this.hexToRgba('#FFFFFF', 0.15);
                ctx.fillRect(-size / 2, -size / 2, size * 0.8, size * 0.12);
                ctx.fillRect(-size / 2, -size / 2, size * 0.12, size * 0.8);
                ctx.fillStyle = ribbonColor;
                ctx.fillRect(-size / 2, -size / 6, size, size / 3);
                ctx.fillRect(-size / 6, -size / 2, size / 3, size);
                ctx.beginPath();
                ctx.arc(0, 0, size / 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = this.hexToRgba('#FFFFFF', 0.3);
                ctx.beginPath();
                ctx.arc(-size / 8, -size / 8, size / 8, 0, Math.PI * 2);
                ctx.arc(size / 8, -size / 8, size / 8, 0, Math.PI * 2);
                ctx.arc(-size / 8, size / 8, size / 8, 0, Math.PI * 2);
                ctx.arc(size / 8, size / 8, size / 8, 0, Math.PI * 2);
                ctx.fill();

                if (sparkle > 0) {
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = `rgba(255, 255, 255, ${sparkle})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
                ctx.restore();
            }

            drawStar(x, y, spikes, outerRadius, innerRadius, color, rotation = 0) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.beginPath();
                for (let i = 0; i < spikes; i++) {
                    let angle = (i * Math.PI * 2) / spikes - Math.PI / 2;
                    ctx.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
                    angle += Math.PI / spikes;
                    ctx.lineTo(Math.cos(angle) * innerRadius, Math.sin(angle) * innerRadius);
                }
                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
                ctx.restore();
            }

            drawLightGlow(x, y, size, color, alpha, glow) {
                const ctx = this.ctx;
                const g = ctx.createRadialGradient(x, y, 0, x, y, glow);
                g.addColorStop(0, `rgba(255,255,255,${Math.min(1, alpha * 1.2)})`);
                g.addColorStop(0.1, this.hexToRgba(color, alpha));
                g.addColorStop(1, this.hexToRgba(color, 0));
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(x, y, glow, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fillStyle = this.hexToRgba(color, Math.min(1, alpha * 1.1));
                ctx.fill();
            }

            hexToRgba(hex, alpha = 1) {
                if (!hex) return `rgba(255,255,255,${alpha})`;
                try {
                    const h = hex.replace('#', '');
                    const bigint = parseInt(h.length === 3 ? h.split('').map(c => c + c).join('') : h, 16);
                    const r = (bigint >> 16) & 255;
                    const g = (bigint >> 8) & 255;
                    const b = bigint & 255;
                    return `rgba(${r},${g},${b},${alpha})`;
                } catch (e) { return `rgba(255,255,255,${alpha})`; }
            }

            drawHexagonSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, size);
                    ctx.lineWidth = size * 0.15;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(size * 0.4, size * 0.5);
                    ctx.moveTo(0, size * 0.3);
                    ctx.lineTo(-size * 0.4, size * 0.5);
                    ctx.moveTo(0, size * 0.7);
                    ctx.lineTo(size * 0.3, size * 0.6);
                    ctx.moveTo(0, size * 0.7);
                    ctx.lineTo(-size * 0.3, size * 0.6);
                    ctx.lineWidth = size * 0.1;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
                    ctx.stroke();
                }
                ctx.restore();
            }

            drawStarSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, size);
                    ctx.moveTo(size * 0.2, size * 0.4);
                    ctx.lineTo(-size * 0.2, size * 0.4);
                    ctx.moveTo(size * 0.15, size * 0.7);
                    ctx.lineTo(-size * 0.15, size * 0.7);
                    ctx.lineWidth = size * 0.08;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.85)";
                    ctx.stroke();
                }
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                ctx.restore();
            }

            drawFlowerSnowflake(x, y, size, rotation, opacity) {
                const ctx = this.ctx;
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
                ctx.fill();
                for (let i = 0; i < 6; i++) {
                    ctx.rotate(Math.PI / 3);
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(size * 0.3, size * 0.2, 0, size);
                    ctx.quadraticCurveTo(-size * 0.3, size * 0.2, 0, 0);
                    ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(0, size * 0.5);
                    ctx.lineTo(0, size * 0.8);
                    ctx.lineWidth = size * 0.05;
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
                    ctx.stroke();
                }
                ctx.restore();
            }
        }

        // ÂàùÂßãÂåñ
        setTimeout(() => {
            if (!window.christmasAnimation) window.christmasAnimation = new ChristmasAnimation();
        }, 500);
        window.onload = () => window.christmasAnimation = new ChristmasAnimation();
    </script>
</body>

</html>